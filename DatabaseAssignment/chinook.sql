/* SECTION 2: SQL QUERIES */

--SECTION 2.1
SELECT * FROM EMPLOYEE; 

SELECT * FROM EMPLOYEE
WHERE LASTNAME = 'King';

SELECT * FROM EMPLOYEE
WHERE FIRSTNAME = 'Andrew' AND REPORTSTO IS NULL;

--SECTION 2.2
SELECT * FROM ALBUM
ORDER BY TITLE DESC;

SELECT FIRSTNAME FROM CUSTOMER
ORDER BY CITY ASC;

--SECTION 2.3
INSERT INTO GENRE VALUES (30, 'Horror');
INSERT INTO GENRE VALUES (31, 'Cookbook');

INSERT INTO EMPLOYEE VALUES(9,'Miller','Jenny','Sales Support Agent',1,'10-Oct-1984','18-JUN-04','5345 Bowness Road NW','Calgary','Canada','AB','T3B 1X9','1 (780) 878-46773', '1 (780) 676-3224', 'jenny@chinookcorp.com');
INSERT INTO EMPLOYEE VALUES(10,'Hinrichs','William','IT Staff',1,'21-Dec-1972','23-NOV-04','78 23 ST','Lethbridge','Canada','AB','T1K 5P4','+1 (403) 782-7897', '1 (403) 234-3458', 'william@chinookcorp.com');

INSERT INTO CUSTOMER VALUES(60, 'Giselle', 'Baker',null,'1012 56TH ST', 'Copenhagen', null, 'Denmark',1724, '+453 4329 3794', null, 'giselle.baker@jubii.dk',4);
INSERT INTO CUSTOMER VALUES(61, 'Pablo', 'Torres','Riotur','PraÃ§a Pio V, 234', 'Rio de Janeiro', 'RJ', 'Brazil',20040-012, '+55 (21) 3480-3452', '+55 (21) 3480-3472', 'ptorres@uol.com.br',3);

--SECTION 2.4
UPDATE CUSTOMER 
SET FIRSTNAME = 'Robert', LASTNAME = 'Walter'
WHERE FIRSTNAME = 'Aaron' AND LASTNAME = 'Mitchell';

UPDATE ARTIST 
SET NAME = 'CCR'
WHERE NAME = 'Creedence Clearwater Revival';

--SECTION 2.5
SELECT * 
FROM INVOICE 
WHERE BILLINGADDRESS LIKE 'T%';

--SECTION 2.6 
SELECT * 
FROM INVOICE 
WHERE TOTAL BETWEEN 15 AND 50;

SELECT * 
FROM EMPLOYEE
WHERE HIREDATE BETWEEN '01-JUN-03' AND '01-MAR-04'; 

--SECTION 2.7
--STEP 1: ALLOW CUSTOMERID TO BE NULL FOR INVOICE TABLE
ALTER TABLE INVOICE MODIFY CUSTOMERID NULL;

--STEP 2: DROP CONSTRAINT BETWEEN INVOICE AND CUSTOMER
ALTER TABLE InvoiceLine DROP CONSTRAINT FK_InvoiceCustomerId;

--STEP 3: RECREATE CONSTRAINT WITH MODIFICATION THAT UPON CUSTOMER DELETION
--THE CUSTOMERID IN THE INVOICE TABLE BECOMES NULL
ALTER TABLE Invoice ADD CONSTRAINT FK_InvoiceCustomerId
    FOREIGN KEY (CustomerId) REFERENCES Customer (CustomerId)
    ON DELETE SET NULL;
    
--STEP 4: DELETE CUSTOMER
DELETE FROM CUSTOMER WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter';

/* SECTION 3 */
--SECTION 3.1

--FUNCTION GET_CURRENT_TIME WITH NO INPUT PARAMETERS
--RETURNS TIMESTAMP AS STRING (VARCHAR2)
CREATE OR REPLACE FUNCTION GET_CURRENT_TIME
RETURN VARCHAR2
IS 
Z VARCHAR2(200);
BEGIN
    --CURRENT_TIMESTAMP BASED ON COMPUTER RUNNING THIS NOT DATABASE TIME
    Z :=  to_char(CURRENT_TIMESTAMP,'DD-MON-YYYY HH24:MI:SS.FF');
    RETURN Z;
END;

--CALL THE FUNCTION
BEGIN 
    DBMS_OUTPUT.PUT_LINE(GET_CURRENT_TIME());
END;

--FUNCTION NAMELENGTH TAKES IN A STRING (VARCHAR)
--RETURNS NUMBER OF CHARACTERS IN STRING
CREATE OR REPLACE FUNCTION NAME_LENGTH(N IN VARCHAR2) 
RETURN NUMBER
IS
Z INTEGER;
BEGIN
    Z:= LENGTH(N);
    RETURN Z;
END;

--QUERY THE TABLE AND USE FUNCTION ON EACH NAME ENTRY
SELECT MEDIATYPE.*, NAME_LENGTH(NAME) FROM MEDIATYPE;

--SECTION 3.2

--FUNCTION TAKES IN NO PARAMETERS
--RETURNS THE AVERAGE ON THE TOTAL COLUMN (AVG OF INVOICE TOTAL)
CREATE OR REPLACE FUNCTION AVERAGE_TOTAL_INVOICES
RETURN NUMBER
IS 
Z NUMBER;
BEGIN
    SELECT AVG(I.TOTAL) INTO Z FROM INVOICE I;
    RETURN Z;
END;

--CALL THE FUNCTION AND PRINT RESULT
BEGIN 
    DBMS_OUTPUT.PUT_LINE('AVERAGE TOTAL OF INVOICES: ' ||AVERAGE_TOTAL_INVOICES());
END;

--FUNCTION TAKES NO PARAMETERS
--RETURNS THE MAX ELEMENT OF THE UNITPRICE COLUMN
CREATE OR REPLACE FUNCTION MOST_EXPENSIVE_TRACK
RETURN NUMBER
IS 
Z NUMBER;
BEGIN
    SELECT MAX(T.UNITPRICE) INTO Z FROM TRACK T; 
    RETURN Z;
END;

--CALL FUNCTION + PRINT RESULT
BEGIN 
    DBMS_OUTPUT.PUT_LINE('THE MOST EXPENSIVE TRACK COSTS: $'||MOST_EXPENSIVE_TRACK());
END;

--SECTION 3.3

--FUNCTION TAKES NO PARAMETERS
--RETURNS THE AVERAGE OF THE UNITPRICE COLUMN
CREATE OR REPLACE FUNCTION AVERAGE_PRICE_INVOICE_LINE
RETURN NUMBER
IS 
Z NUMBER;
BEGIN
    SELECT AVG(I.UNITPRICE) INTO Z FROM INVOICELINE I;
    RETURN Z;
END;

--CALL FUNCTION + PRINT RESULTS
BEGIN
    DBMS_OUTPUT.PUT_LINE('AVERAGE PRICE OF INVOICE ITEMS: $' || AVERAGE_PRICE_INVOICE_LINE());
END;

--SECTION 3.4
--FUNCTIONS TAKES NO PARAMETERS
--RETURNS HOW MANY EMPLOYEES WERE BORN AFTER THE YEAR 1968
CREATE OR REPLACE FUNCTION TOTAL_EMPLOYEES_1968
RETURN NUMBER
IS 
Z NUMBER;
BEGIN
    SELECT COUNT(E.EMPLOYEEID) INTO Z FROM EMPLOYEE E
    --USED EXTRACT TO GET THE YEAR FROM A DATE FIELD
    WHERE EXTRACT(YEAR FROM E.BIRTHDATE) > 1968;
    RETURN Z;
END;

--CALL FUNCTION + PRINT RESULT
BEGIN
    DBMS_OUTPUT.PUT_LINE('THERE ARE ' || TOTAL_EMPLOYEES_1968 || ' EMPLOYEES BORN AFTER 1968');
END;


/* SECTION 4 */
--SECTION 4.1
--PROCEDURES TAKES IN A CURSOR WHICH ALLOWS US
--RETURNS A RESULT SET
--THE RESULT SET GIVES US FIRST NAME + LAST NAME OF ALL EMPLOYEES
CREATE OR REPLACE PROCEDURE GET_ALL_EMPLOYEES (S OUT SYS_REFCURSOR) 
IS 
BEGIN
OPEN S FOR
SELECT E.FIRSTNAME, E.LASTNAME FROM EMPLOYEE E;
END;

--CALL THE PROCEDURE WITH A CURSOR
--THEN LOOP THROUGH THE VALUES IN THE CURSOR
--TO PRINT FIRST NAME + LAST NAME OF EMPLOYEES 
DECLARE 
S SYS_REFCURSOR;
SOME_FN EMPLOYEE.FIRSTNAME%TYPE;
SOME_LN EMPLOYEE.LASTNAME%TYPE;
BEGIN
    GET_ALL_EMPLOYEES(S);
    DBMS_OUTPUT.PUT_LINE('EMPLOYEES: ');
    LOOP
        FETCH S INTO SOME_FN, SOME_LN;
        EXIT WHEN S%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(SOME_FN||' '||SOME_LN);
    END LOOP;
    CLOSE S;
END;

--SECTION 4.2
--USED PERSONAL INFORMATION: TITLE, REPORTSTO COLUMNS BUT COULD CHANGE UP PARAMETERS
--PROCEDURE TAKES IN EMPLOYEE ID TO FIND THE EMPLOYEE TO UPDATE
--CHECK IF THE EMPLOYEE EXISTS
--IF THE EMPLOYEE EXISTS THEN WE UPDATE THE FIELDS WITH INPUT PARAMETERS
CREATE OR REPLACE PROCEDURE UPDATE_EMPLOYEE(E_ID IN NUMBER, T IN VARCHAR2, R IN NUMBER)
IS
E_EXISTS INTEGER;
BEGIN
SELECT COUNT(E.EMPLOYEEID) INTO E_EXISTS FROM EMPLOYEE E
WHERE E.EMPLOYEEID = E_ID;
DBMS_OUTPUT.PUT_LINE(E_EXISTS);
    IF E_EXISTS > 0 THEN
        UPDATE EMPLOYEE
        SET TITLE = T, REPORTSTO = R
        WHERE EMPLOYEEID = E_ID;
        DBMS_OUTPUT.PUT_LINE('UPDATED EMPLOYEE TITLE, MANAGER');
    ELSE 
        DBMS_OUTPUT.PUT_LINE('DID NOT UPDATE EMPLOYEE INFORMATION');
    END IF;
END;

--CALL UPDATE PROCEDURE
BEGIN
    UPDATE_EMPLOYEE(10, 'CEO', 10);
END;

--PASS EMPLOYEE ID AND RETURNS LIST OF MANAGERS OF THAT EMPLOYEE USING CURSOR
--USING A SUBQUERY WE QUERY TO FIND THE MANAGER OF A PARTICULAR EMPLOYEE
--
CREATE OR REPLACE PROCEDURE GET_MANAGERS(E_ID IN NUMBER, S OUT SYS_REFCURSOR) 
IS 
BEGIN
OPEN S FOR
    SELECT M.EMPLOYEEID, M.FIRSTNAME, M.LASTNAME FROM EMPLOYEE M
    WHERE M.EMPLOYEEID IN (
    SELECT E.REPORTSTO FROM EMPLOYEE E
    WHERE E.EMPLOYEEID = E_ID);
END;

--CALL THE PROCEDURE PASSING AN EMPLOYEE ID + CURSOR
--GET RESULT SET WITH FIRST NAME + LAST NAME OF MANAGERS
DECLARE 
S SYS_REFCURSOR;
SOME_MID EMPLOYEE.EMPLOYEEID%TYPE;
SOME_FN EMPLOYEE.FIRSTNAME%TYPE;
SOME_LN EMPLOYEE.FIRSTNAME%TYPE;
BEGIN
    GET_MANAGERS(4,S);
    DBMS_OUTPUT.PUT_LINE('MANAGERS:');
    LOOP
        FETCH S INTO SOME_MID, SOME_FN, SOME_LN;
        EXIT WHEN S%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(SOME_FN || ' ' || SOME_LN);
    END LOOP;
    CLOSE S;
END;

--SECTION 4.3
--PROCEDURE TAKES IN CUSTOMER ID + CURSOR
--RETURNS RESULT SET WITH COMPANY, FIRST NAME + LAST NAME OF CUSTOMER
CREATE OR REPLACE PROCEDURE GET_CUSTOMER(C_ID IN NUMBER, S OUT SYS_REFCURSOR) 
IS 
BEGIN
OPEN S FOR
    SELECT C.COMPANY, C.FIRSTNAME, C.LASTNAME FROM CUSTOMER C WHERE C.CUSTOMERID = C_ID;
END;

--CALL PROCEDURE WITH CUSTOMER ID + CURSOR
--FETCH THE CUSTOMER INFORMATION INTO VARIABLES AND PRINT INFORMATION TO CONSOLE
DECLARE 
S SYS_REFCURSOR;
SOME_C CUSTOMER.COMPANY%TYPE;
SOME_FN CUSTOMER.FIRSTNAME%TYPE;
SOME_LN CUSTOMER.LASTNAME%TYPE;
BEGIN
    GET_CUSTOMER(11,S);
    FETCH S INTO SOME_C, SOME_FN, SOME_LN;
    DBMS_OUTPUT.PUT_LINE(SOME_FN||' '||SOME_LN||', '||SOME_C);
    CLOSE S;
END;

/* SECTION 5 */
--PROCEDURE TAKES IN INVOICE ID
--CHECKS WHETHER INVOICE EXISTS
--ATTEMPTS TO DELETE INVOICE AND PRINTS THE INVOICE ID
--COMMITS THE TRANSACTION IF SUCCESSFUL
--ROLLSBACK IF NOT
CREATE OR REPLACE PROCEDURE DELETE_INVOICE(I_ID IN NUMBER) 
IS 
I_EXISTS NUMBER;
BEGIN 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
DBMS_OUTPUT.PUT_LINE('Attemption to delete invoice...');
SELECT COUNT(I.INVOICEID) INTO I_EXISTS FROM INVOICE I
WHERE I.INVOICEID = I_ID;
    IF I_EXISTS>0 THEN
        DELETE FROM INVOICE I
        WHERE I.INVOICEID = I_ID;
        DBMS_OUTPUT.PUT_LINE('WILL DELETE INVOICE: ' || I_ID);
    ELSE
        DBMS_OUTPUT.PUT_LINE('DID NOT FIND INVOICE: ' || I_ID);    
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('EXCEPTION ERROR');
    ROLLBACK;
END;

--CALL PROCEDURE WITH INVOICE ID
BEGIN
    DELETE_INVOICE(320);
END;

--CREATED CUSTOMER BASED ON NON-NULL PARAMETERS
--PROCEDURE TAKES IN PARAMETERS
--CHECKS WHETHER CUSTOMER ALREADY EXISTS BASED ON FIRST NAME + LAST NAME
--IF NOT THEN INSERTS CUSTOMER WITH INPUT INFORMATION 
CREATE OR REPLACE PROCEDURE ADD_CUSTOMER(CID IN NUMBER, FN IN VARCHAR2, LN IN VARCHAR2, EM  IN VARCHAR2)
IS 
C_EXISTS NUMBER; 
BEGIN
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
DBMS_OUTPUT.PUT_LINE('Creating customer...');
SELECT COUNT(C.FIRSTNAME) INTO C_EXISTS FROM CUSTOMER C
WHERE C.FIRSTNAME = FN 
AND C.LASTNAME = LN;
IF C_EXISTS > 0 THEN
    DBMS_OUTPUT.PUT_LINE('CUSTOMER ALREADY EXISTS');
ELSE
    INSERT INTO 
    CUSTOMER(CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL) 
    VALUES (CID, FN, LN, EM);
    DBMS_OUTPUT.PUT_LINE('CREATED CUSTOMER');
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('EXCEPTION ERROR');
ROLLBACK;
END;

--CALL INSERT PROCEDURE
BEGIN
 ADD_CUSTOMER(100, 'Alice','Liddell', 'alice@wonderland.com');
END;


/* SECTION 6 */
--SECTION 6.1

--TRIGGER PRINTS THE EMPLOYEE ID OF EMPLOYEE INSERTED INTO TABLE  
CREATE OR REPLACE TRIGGER INSERT_EMPLOYEE_TRIGGER
AFTER INSERT ON EMPLOYEE
FOR EACH ROW
DECLARE 
    E_ID NUMBER;
BEGIN
    E_ID := :NEW.EMPLOYEEID;
    DBMS_OUTPUT.PUT_LINE('CREATED EMPLOYEE WITH ID: '||E_ID);
END;

--INSERT AND UPON INSERT TRIGGER WILL PRINT EMPLOYEE ID
BEGIN
    INSERT INTO EMPLOYEE (FIRSTNAME, LASTNAME)
    VALUES ('KIM','LERNER');
END;

--AFTER UPDATE TRIGGER
--UPON UPDATE OF ALBUM NAME 
--TRIGGER WILL PRINT THE OLD NAME AND NEW NAME OF THE ALBUM UPDATED
CREATE OR REPLACE TRIGGER AFTER_UPDATE_ALBUM
AFTER UPDATE ON ALBUM
FOR EACH ROW
DECLARE
    OA VARCHAR2(200);
    NA VARCHAR2(200);
BEGIN
    OA := :OLD.TITLE;
    NA := :NEW.TITLE;
    DBMS_OUTPUT.PUT_LINE('ALBUM TITLE UPDATED FROM '||OA||' TO '||NA);
END;

BEGIN
    --INSERT INTO ALBUM FOR TESTING
    INSERT INTO ALBUM
    VALUES (900000, 'ILLUMINATE',5);
    
    --COMMIT TRANSACTION
    COMMIT;
    
    --UPDATE THE ALBUM AND TRIGGER WILL PRINT ALBUM NAME CHANGE
    UPDATE ALBUM
    SET TITLE = 'SLEEP WELL'
    WHERE ALBUMID = 900000;
END;

--UPON DELETING CUSTOMER THE TRIGGER WILL PRINT THE NAME OF THE CUSTOMER DELETED
CREATE OR REPLACE TRIGGER AFTER_DELETE_CUSTOMER
AFTER DELETE ON CUSTOMER
FOR EACH ROW
DECLARE
    OFN VARCHAR2(200);
    OLN VARCHAR2(200);
BEGIN
    OFN := :OLD.FIRSTNAME;
    OLN := :OLD.LASTNAME;
    DBMS_OUTPUT.PUT_LINE('DELETED CUSTOMER: '||OFN||' '||OLN);
END;

--DELETE CUSTOMER AND TRIGGER WILL PRINT CUSTOMER NAME 
BEGIN
    DELETE FROM CUSTOMER 
    WHERE CUSTOMERID = 48;
    ROLLBACK;
END;

/* SECTION 7 */
--SECTION 7.1

SELECT CUSTOMER.FIRSTNAME, INVOICE.INVOICEID
FROM CUSTOMER
INNER JOIN INVOICE ON CUSTOMER.CUSTOMERID = INVOICE.CUSTOMERID;

--SECTION 7.2
SELECT CUSTOMER.CUSTOMERID, CUSTOMER.FIRSTNAME, CUSTOMER.LASTNAME, INVOICE.INVOICEID, INVOICE.TOTAL
FROM CUSTOMER
FULL OUTER JOIN INVOICE ON CUSTOMER.CUSTOMERID = INVOICE.CUSTOMERID;

--SECTION 7.3
SELECT ALBUM.TITLE, ARTIST.NAME
FROM ALBUM
RIGHT JOIN ARTIST ON ALBUM.ARTISTID = ARTIST.ARTISTID;

--SECTION 7.4
SELECT * 
FROM ALBUM
CROSS JOIN ARTIST
ORDER BY ARTIST.NAME ASC;

--SECTION 7.5
SELECT * 
FROM EMPLOYEE E1
JOIN EMPLOYEE E2 ON E1.REPORTSTO = E2.REPORTSTO;


