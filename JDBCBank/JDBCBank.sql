--CREATE A USERS, USER_TYPE, AND BANK_ACCOUNTS TABLE

CREATE TABLE USERS(
    USER_ID INTEGER PRIMARY KEY,
    USER_TYPE_ID INTEGER NOT NULL,
    USER_NAME VARCHAR2(100) NOT NULL,
    USER_PASSWORD VARCHAR2(100) NOT NULL
);

CREATE TABLE USER_TYPE(
    USER_TYPE_ID INTEGER PRIMARY KEY,
    USER_TYPE VARCHAR2(100) NOT NULL
);

CREATE TABLE BANK_ACCOUNTS(
    BANK_ACCOUNT_ID INTEGER PRIMARY KEY,
    USER_ID INTEGER NOT NULL,
    BALANCE NUMBER(10,2)
);

CREATE TABLE TRANSACTIONS(
    TRANSACTION_ID INTEGER PRIMARY KEY,
    TRANSACTION_DATE DATE,
    BANK_ACCOUNT_ID INTEGER,
    TRANSACTION_INFO VARCHAR2(200)
);

ALTER SESSION SET TIME_ZONE = '+8:0';
ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';

-- ADD FOREIGN KEY CONSTRAINTS TO THE TABLES 

ALTER TABLE USERS
ADD CONSTRAINT FK_USERS_USER_TYPE
FOREIGN KEY (USER_TYPE_ID) REFERENCES USER_TYPE(USER_TYPE_ID);

ALTER TABLE TRANSACTIONS
ADD CONSTRAINT FK_TRANSACTIONS_BANK_ACCOUNTS
FOREIGN KEY (BANK_ACCOUNT_ID) 
REFERENCES BANK_ACCOUNTS(BANK_ACCOUNT_ID)
ON DELETE CASCADE;

ALTER TABLE BANK_ACCOUNTS
ADD CONSTRAINT FK_BANK_ACCOUNTS_USERS
FOREIGN KEY (USER_ID)
REFERENCES USERS(USER_ID)
ON DELETE CASCADE;


ALTER TABLE USERS
ADD UNIQUE (USER_NAME);

-- INSERT INFO INTO USER_TYPE TABLE

INSERT INTO USER_TYPE VALUES(1, 'REGISTERED USER');
INSERT INTO USER_TYPE VALUES(2, 'SUPERUSER');

-- CREATE SEQUENCES FOR PRIMARY KEY

CREATE SEQUENCE SQ_USER_ID_PK
START WITH 1
INCREMENT BY 3;

CREATE SEQUENCE SQ_BANK_ACCOUNT_ID_PK
START WITH 100
INCREMENT BY 6;

CREATE SEQUENCE SQ_TRANSACTION_ID_PK
START WITH 1000
INCREMENT BY 12;

-- CREATE BEFORE INSERT TRIGGERS

CREATE OR REPLACE TRIGGER TR_INSERT_USER
BEFORE INSERT ON USERS
FOR EACH ROW
BEGIN
    SELECT SQ_USER_ID_PK.NEXTVAL INTO :NEW.USER_ID FROM DUAL;
END;

CREATE OR REPLACE TRIGGER TR_INSERT_BANK_ACCOUNT_ID_PK
BEFORE INSERT ON BANK_ACCOUNTS
FOR EACH ROW 
BEGIN
    SELECT SQ_BANK_ACCOUNT_ID_PK.NEXTVAL 
    INTO :NEW.BANK_ACCOUNT_ID FROM DUAL;
END;

CREATE OR REPLACE TRIGGER TR_INSERT_TRANSACTION_ID_PK
BEFORE INSERT ON TRANSACTIONS
FOR EACH ROW 
BEGIN
    SELECT SQ_TRANSACTION_ID_PK.NEXTVAL
    INTO :NEW.TRANSACTION_ID FROM DUAL;
END;

-- INSERT A SUPERUSER ALONG WITH CORRESPONDING BANK ACCOUNT 

INSERT INTO USERS(USER_TYPE_ID, USER_NAME, USER_PASSWORD) 
VALUES(2, 'ADMIN', 'P4SSW0RD'); 

INSERT INTO BANK_ACCOUNTS(USER_ID, BALANCE) VALUES (1, 2000);

-- PROCEDURE TO CREATE NEW USER 

CREATE OR REPLACE PROCEDURE REGISTER_NEW_USER
(UT_ID IN NUMBER, U_NAME IN VARCHAR2, U_PW IN VARCHAR2)
IS
UN_EXISTS INTEGER;
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(USER_NAME) INTO UN_EXISTS 
    FROM USERS
    WHERE USER_NAME = U_NAME;
    IF UN_EXISTS = 0 THEN 
        INSERT INTO USERS(USER_TYPE_ID, USER_NAME, USER_PASSWORD)
        VALUES(UT_ID, U_NAME, U_PW);
        DBMS_OUTPUT.PUT_LINE('NEW USER CREATED');
    ELSE 
        DBMS_OUTPUT.PUT_LINE('USERNAME IS NOT AVAILABLE');
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO REGISTER NEW USER');
    ROLLBACK;
END;

-- PROCEDURE FOR USER TO CREATE A BANK ACCOUNT 

CREATE OR REPLACE PROCEDURE CREATE_BANK_ACC
(U_ID IN NUMBER, BAL IN NUMBER)
IS
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    INSERT INTO BANK_ACCOUNTS(USER_ID, BALANCE)
    VALUES(U_ID, BAL);
    DBMS_OUTPUT.PUT_LINE('NEW BANK ACCOUNT CREATED');
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO CREATE NEW BANK ACCOUNT');
    ROLLBACK;
END;

-- FUNCTION TO VIEW ALL BANK ACCOUNTS OF A CERTAIN USER 

CREATE OR REPLACE FUNCTION VIEW_ACCOUNTS(U_ID IN NUMBER)
RETURN SYS_REFCURSOR
AS
S SYS_REFCURSOR;
BEGIN 
    OPEN S FOR SELECT BANK_ACCOUNT_ID, BALANCE
    FROM BANK_ACCOUNTS WHERE USER_ID = U_ID;
    RETURN S;
END;

-- PROCEDURE TO DELETE ACCOUNT

CREATE OR REPLACE PROCEDURE DELETE_BANK_ACCOUNT(ACC_ID IN NUMBER)
AS
BAL_VALUE NUMBER;
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT BALANCE INTO BAL_VALUE FROM BANK_ACCOUNTS 
    WHERE BANK_ACCOUNT_ID = ACC_ID;
    IF BAL_VALUE = 0 THEN
        DELETE FROM BANK_ACCOUNTS WHERE BANK_ACCOUNT_ID = ACC_ID;
        DBMS_OUTPUT.PUT_LINE('BANK ACCOUNT DELETED');
    ELSE 
        DBMS_OUTPUT.PUT_LINE('BANK ACCOUNT IS NOT EMPTY.. 
        CAN NOT DELETE ACCOUNT');
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO DELETE');   
    ROLLBACK;
END;

-- PROCEDURE TO WITHDRAW MONEY FROM AN ACCOUNT

CREATE OR REPLACE PROCEDURE WITHDRAW_MONEY
(ACC_ID IN NUMBER, AMT IN NUMBER)
AS
BAL_VAL NUMBER;
TRANS_INFO VARCHAR2(200);
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT BALANCE INTO BAL_VAL FROM BANK_ACCOUNTS
    WHERE BANK_ACCOUNT_ID = ACC_ID;
    IF BAL_VAL >= AMT THEN
        UPDATE BANK_ACCOUNTS SET BALANCE = BALANCE - AMT
        WHERE BANK_ACCOUNT_ID = ACC_ID;
        DBMS_OUTPUT.PUT_LINE('WITHDRAWAL SUCCESSFUL');
        TRANS_INFO := 'WITHDREW' || TO_CHAR(AMT, '$99999.99');
        INSERT INTO TRANSACTIONS(TRANSACTION_DATE, BANK_ACCOUNT_ID, TRANSACTION_INFO)
        VALUES(CURRENT_DATE, ACC_ID, TRANS_INFO);
    ELSE
        DBMS_OUTPUT.PUT_LINE('UNABLE TO WITHDRAW..WITHDRAWAL AMOUNT
        IS GREATER THAN BANK ACCOUNT BALANCE');
    END IF;
    COMMIT;
    EXCEPTION 
    WHEN OTHERS THEN 
    DBMS_OUTPUT.PUT_LINE('FAILED TO WITHDRAW');
    ROLLBACK;
END;

BEGIN
    WITHDRAW_MONEY(106, 50);
END;

-- PROCEDURE TO DEPOSIT MONEY INTO AN ACCOUNT 

CREATE OR REPLACE PROCEDURE DEPOSIT_MONEY
(ACC_ID IN NUMBER, AMT IN NUMBER)
AS
TRANS_INFO VARCHAR2(200);
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    UPDATE BANK_ACCOUNTS SET BALANCE = BALANCE + AMT
    WHERE BANK_ACCOUNT_ID = ACC_ID;
    DBMS_OUTPUT.PUT_LINE('SUCCESSFUL DEPOSIT');
    TRANS_INFO := 'DEPOSITED' || TO_CHAR(AMT, '$99999.99');
    INSERT INTO TRANSACTIONS(TRANSACTION_DATE, BANK_ACCOUNT_ID, TRANSACTION_INFO)
    VALUES(CURRENT_DATE, ACC_ID, TRANS_INFO);
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN 
    DBMS_OUTPUT.PUT_LINE('FAILED TO DEPOSIT');
    ROLLBACK;
END;

BEGIN
    DEPOSIT_MONEY(106, 500);
END;

--  PROCEDURE TO ADD NEW TRANSACTION HISTORY 

CREATE OR REPLACE PROCEDURE ADD_TRANSACTION
(BANK_ACC_ID IN NUMBER, TRANS IN VARCHAR2)
IS 
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    INSERT INTO TRANSACTIONS(TRANSACTION_DATE, BANK_ACCOUNT_ID, TRANSACTION_INFO)
    VALUES(CURRENT_DATE, BANK_ACC_ID, TRANS);
    DBMS_OUTPUT.PUT_LINE('NEW TRANSACTION HISTORY ADDED');
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('UNABLE TO ADD TRANSACTION HISTORY');
    ROLLBACK;
END;

-- FUNCTION FOR USER TO VIEW TRANSACTION HISTORY FOR A CERTAIN BANK ACCOUNT

CREATE OR REPLACE FUNCTION VIEW_TRANSACTION
(ACC_ID IN NUMBER)
RETURN SYS_REFCURSOR
AS
S SYS_REFCURSOR;
BEGIN 
    OPEN S FOR SELECT TRANSACTION_ID, TRANSACTION_DATE, TRANSACTION_INFO
    FROM TRANSACTIONS
    WHERE BANK_ACCOUNT_ID = ACC_ID
    ORDER BY TRANSACTION_DATE;
    RETURN S;
END;

-- PROCEDURE TO UPDATE USER PASSWORD 

CREATE OR REPLACE PROCEDURE UPDATE_PW(U_ID IN NUMBER, PW IN VARCHAR2)
IS
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    UPDATE USERS SET USER_PASSWORD = PW 
    WHERE USER_ID = U_ID;
    DBMS_OUTPUT.PUT_LINE('PASSWORD FOR USER ' || U_ID 
    || ' HAS BEEN UPDATED');
    COMMIT;
    EXCEPTION 
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO UPDATE PASSWORD');
    ROLLBACK;
END;

-- PROCEDURE FOR SUPERUSER TO DELETE USER

CREATE OR REPLACE PROCEDURE DELETE_USER(U_ID IN NUMBER)
IS
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    DELETE FROM USERS WHERE USER_ID = U_ID;
    DBMS_OUTPUT.PUT_LINE('USER HAVE BEEN DELETED');
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO DELETE USER');
    ROLLBACK;
END;
