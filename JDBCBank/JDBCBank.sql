CREATE SEQUENCE SQ_PK_USER
START WITH 5000
INCREMENT BY 5;

CREATE SEQUENCE SQ_PK_ACCOUNT
START WITH 7000
INCREMENT BY 7;

CREATE SEQUENCE SQ_PK_TRANSACTION
START WITH 9000
INCREMENT BY 9;

CREATE OR REPLACE TRIGGER TR_INSERT_USER
BEFORE INSERT ON USERS
FOR EACH ROW
BEGIN
    SELECT SQ_PK_USER.NEXTVAL INTO :NEW.USERID FROM DUAL;
END;

CREATE OR REPLACE TRIGGER TR_INSERT_ACCOUNT
BEFORE INSERT ON ACCOUNTS
FOR EACH ROW
BEGIN
    SELECT SQ_PK_ACCOUNT.NEXTVAL INTO :NEW.ACCOUNTID FROM DUAL;
END;


CREATE OR REPLACE TRIGGER TR_INSERT_TRANSACTION
BEFORE INSERT ON TRANSACTIONS
FOR EACH ROW
BEGIN
    SELECT SQ_PK_TRANSACTION.NEXTVAL INTO :NEW.TRANSACTIONID FROM DUAL;
END;

CREATE TABLE USERS(
    USERID NUMBER NOT NULL,
    USERNAME VARCHAR2(100) NOT NULL UNIQUE,
    PASSKEY VARCHAR2(100) NOT NULL, --PASSWORD
    USERTYPE VARCHAR2(10) NOT NULL CONSTRAINT UTYPE CHECK (USERTYPE IN ('C','A')),
    FIRSTNAME VARCHAR2(40),
    LASTNAME VARCHAR2(20),
    ADDRESS VARCHAR2(70),
    CITY VARCHAR2(40),
    STATE VARCHAR2(40),
    COUNTRY VARCHAR2(40),
    POSTALCODE VARCHAR2(10),
    PHONE VARCHAR2(24),
    EMAIL VARCHAR2(60),
    CONSTRAINT PK_USER PRIMARY KEY (USERID)
);

CREATE TABLE ACCOUNTS (
    ACCOUNTID NUMBER NOT NULL,
    ACCOUNTUSER NUMBER NOT NULL,
    ACCOUNTTYPE VARCHAR2(10) NOT NULL, --CONSTRAINT ATYPE CHECK (ACCOUNTTYPE IN ('C','S')),
    BALANCE NUMBER NOT NULL,
    ACCOUNTNUMBER VARCHAR2(20) UNIQUE,
    OPENDATE VARCHAR2(50) DEFAULT to_char(CURRENT_TIMESTAMP,'DD-MON-YYYY HH24:MI:SS.FF'),
    CONSTRAINT PK_ACCOUNT PRIMARY KEY (ACCOUNTID),
    CONSTRAINT FK_ACCOUNT_USER FOREIGN KEY (ACCOUNTUSER) REFERENCES USERS(USERID) ON DELETE CASCADE
);

CREATE TABLE TRANSACTIONS (
    TRANSACTIONID NUMBER NOT NULL,
    TRANSACTIONACCOUNT NUMBER NOT NULL,
    TRANSACTIONTYPE VARCHAR2(10) NOT NULL CONSTRAINT TTYPE CHECK (TRANSACTIONTYPE IN ('W','D')),
    TRANSACTIONTIME VARCHAR2(50) DEFAULT to_char(CURRENT_TIMESTAMP,'DD-MON-YYYY HH24:MI:SS.FF'),
    PRIORBALANCE NUMBER NOT NULL,
    CURRENTBALANCE NUMBER NOT NULL,
    CONSTRAINT PK_TRANSACTION PRIMARY KEY (TRANSACTIONID),
    CONSTRAINT FK_TRANSACTION_ACCOUNT FOREIGN KEY (TRANSACTIONACCOUNT) REFERENCES ACCOUNTS(ACCOUNTID) ON DELETE CASCADE
);

--LOGIN 
--UE > 0 LOGIN SUCESS
--UE = 0 LOGIN FAIL
CREATE OR REPLACE PROCEDURE LOGIN(UN IN VARCHAR2, PW IN VARCHAR2, UE OUT NUMBER, S OUT SYS_REFCURSOR)
IS 
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(USERID) INTO UE FROM USERS WHERE USERNAME=UN AND PASSKEY=PW;
    IF UE > 0 THEN
        OPEN S FOR
            SELECT USERID, USERTYPE FROM USERS WHERE USERNAME=UN AND PASSKEY=PW;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;


BEGIN
    DBMS_OUTPUT.PUT_LINE(LOGIN('Jenny','jenny'));
END;

--REGISTER
--UE = 0 REGISTER SUCCESS
--UE > 0 REGISTER FAIL
CREATE OR REPLACE PROCEDURE REGISTER_USER(UN IN VARCHAR2, PW IN VARCHAR2, UE OUT NUMBER)
IS 
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 
    SELECT COUNT (USERNAME) INTO UE FROM USERS WHERE USERNAME = UN;
    IF UE = 0 THEN
        INSERT INTO USERS (USERNAME, PASSKEY, USERTYPE)
        VALUES (UN, PW, 'C');
    ELSE 
        UE := 1; 
    END IF;    
END;

BEGIN 
    REGISTER_USER('UUE','UU-');
END;

--VIEW USERS (ADMIN)
CREATE OR REPLACE PROCEDURE VIEW_USERS(AI IN NUMBER, S OUT SYS_REFCURSOR) 
IS 
AE NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(U.USERID) INTO AE FROM USERS U
    WHERE U.USERID=AI AND U.USERTYPE='A'; 
    IF AE > 0 THEN
        OPEN S FOR
            SELECT USERID, USERNAME, USERTYPE FROM USERS;
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    ROLLBACK;
END;

DECLARE
S SYS_REFCURSOR;
S_UID USERS.USERID%TYPE;
S_UN USERS.USERNAME%TYPE;
S_UT USERS.USERTYPE%TYPE;
BEGIN 
    VIEW_USERS(5105,S);
    LOOP
        FETCH S INTO S_UID, S_UN, S_UT;
        EXIT WHEN S%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(S_UID || ' ' || S_UN||' '||S_UT);
    END LOOP;
    CLOSE S;
END;

--CREATE USER
--AC == 0 SUCESS
--AC > 0 FAIL
CREATE OR REPLACE PROCEDURE CREATE_USER(AI IN NUMBER, UN IN VARCHAR2, PW IN VARCHAR2, ACT IN VARCHAR2, AC OUT NUMBER)
IS 
AE NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(USERID) INTO AE FROM USERS WHERE USERID = AI AND USERTYPE = 'A';
    IF AE > 0 THEN
        SELECT COUNT(USERID) INTO AC FROM USERS WHERE USERNAME = UN;
        IF AC = 0 THEN
            INSERT INTO USERS(USERNAME,PASSKEY,USERTYPE)
            VALUES(UN,PW,ACT);
        END IF;
    ELSE 
        AC:=1;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN  
    ROLLBACK;
END;

BEGIN
    CREATE_USER('TTD','ttd','C');
END;

--UPDATE USER 
--AC > 0 SUCESS
--AC == 0 FAIL
CREATE OR REPLACE PROCEDURE UPDATE_USER(AI IN NUMBER, UI IN NUMBER, UN IN VARCHAR2, PW IN VARCHAR2, UT IN VARCHAR2, AC OUT NUMBER)
IS 
AE NUMBER;
BEGIN 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(USERID) INTO AE FROM USERS 
    WHERE USERID = AI AND USERTYPE = 'A';
    IF AE > 0 THEN
        SELECT COUNT(USERID) INTO AC FROM USERS WHERE USERID = UI;
        IF AC > 0 THEN
            UPDATE USERS
            SET USERNAME = UN, PASSKEY = PW, USERTYPE = UT
            WHERE USERID = UI;
        END IF;
    ELSE
        AC:=0;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
END;

BEGIN
    UPDATE_USER(5105,5025,'TT','tt*','C');
END;


--DELETE USER (ADMIN)
CREATE OR REPLACE PROCEDURE DELETE_USER(AI IN NUMBER, UI IN NUMBER, AC OUT NUMBER) 
IS 
AE NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(USERID) INTO AE FROM USERS
    WHERE USERID = AI AND USERTYPE = 'A';
    IF AE > 0 THEN
        SELECT COUNT(USERID) INTO AC FROM USERS WHERE USERID = UI;
        IF AC > 0 THEN
            DELETE FROM USERS
            WHERE USERID = UI;
        END IF;
      ELSE
        AC:=1;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
END;
  
BEGIN 
    DELETE_USER(5105, 5025);
END;

--CREATE ACCOUNT
CREATE OR REPLACE PROCEDURE CREATE_ACCOUNT(UI IN VARCHAR2, ACT IN VARCHAR, B IN NUMBER) 
IS 
U_EXISTS NUMBER;
BEGIN 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(U.USERID) INTO U_EXISTS FROM USERS U
WHERE U.USERID = UI;
    IF U_EXISTS > 0 THEN
        INSERT INTO ACCOUNTS(ACCOUNTUSER, ACCOUNTTYPE, BALANCE, OPENDATE)
        VALUES(UI, ACT, B, DEFAULT);
        DBMS_OUTPUT.PUT_LINE('CREATED ACCOUNT');

    ELSE
        DBMS_OUTPUT.PUT_LINE('ERROR THAT USER DOES NOT EXIST');
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('EXCEPTION ERROR');
    ROLLBACK;
END;

BEGIN 
    CREATE_ACCOUNT(5020,'Savings',12300);
END;

--VIEW ACCOUNTS

CREATE OR REPLACE PROCEDURE VIEW_ACCOUNTS(UI IN NUMBER, S OUT SYS_REFCURSOR) 
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTUSER) INTO A_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTUSER=UI; 
    IF A_EXISTS > 0 THEN
        OPEN S FOR
        SELECT ACCOUNTID, ACCOUNTUSER, ACCOUNTTYPE, BALANCE, OPENDATE FROM ACCOUNTS A
        WHERE A.ACCOUNTUSER = UI; 
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    ROLLBACK;
END;

DECLARE
S SYS_REFCURSOR;
S_AI ACCOUNTS.ACCOUNTID%TYPE;
S_AU  ACCOUNTS.ACCOUNTUSER%TYPE;
S_AT  ACCOUNTS.ACCOUNTTYPE%TYPE;
S_B  ACCOUNTS.BALANCE%TYPE;
S_D  ACCOUNTS.OPENDATE%TYPE;
BEGIN 
    VIEW_ACCOUNTS(5020,S);
    LOOP
        FETCH S INTO S_AI, S_AU, S_AT, S_B, S_D;
        EXIT WHEN S%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(S_AI || ' ' || S_AU||' '||S_AT||' '||S_B||' '||S_D);
    END LOOP;
    CLOSE S;
END;

--DELETE ACCOUNT (INCOMPLETE)
CREATE OR REPLACE PROCEDURE DELETE_ACCOUNT(AI IN NUMBER, S OUT SYS_REFCURSOR)
IS 
UA_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTID) INTO UA_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTID=AI; 
    IF UA_EXISTS > 0 THEN
        DELETE ACCOUNTS A
        WHERE A.ACCOUNTID = AI AND A.BALANCE = 0; 
        DBMS_OUTPUT.PUT_LINE('DELETE ACCOUNT: '||AI);
    ELSE 
        DBMS_OUTPUT.PUT_LINE('NO ACCOUNTS FOR USER');
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO RETRIEVE ACCOUNTS');

ROLLBACK;
END;

     
DECLARE
S SYS_REFCURSOR;
BEGIN 
    DELETE_ACCOUNT(7000,S);
END;   

--DEPOSIT ACCOUNT

CREATE OR REPLACE PROCEDURE ACCOUNT_DEPOSIT(AI IN NUMBER, AMT IN NUMBER)
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTID) INTO A_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTID=AI; 
    IF A_EXISTS > 0 THEN 
        DBMS_OUTPUT.PUT_LINE('DEPOSIT TO ACCOUNT: '||AI||' THE AMOUNT '||AMT);
        UPDATE ACCOUNTS A
            SET BALANCE = (AMT + A.BALANCE)
        WHERE A.ACCOUNTID = AI;
    ELSE 
        DBMS_OUTPUT.PUT_LINE('NO ACCOUNTS FOR USER');
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO DEPOSIT TO ACCOUNT');
ROLLBACK;
END;

BEGIN 
    ACCOUNT_DEPOSIT(7000,10);
END;


CREATE OR REPLACE PROCEDURE ACCOUNT_WITHDRAWAL(AI IN NUMBER, AMT IN NUMBER)
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTID) INTO A_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTID=AI; 
    IF A_EXISTS > 0 THEN 
        DBMS_OUTPUT.PUT_LINE('WITHDRAW FROM ACCOUNT: '||AI||'THE AMOUNT'||AMT);
        UPDATE ACCOUNTS A
            SET BALANCE = (A.BALANCE - AMT)
            WHERE A.ACCOUNTID = AI AND A.BALANCE >= AMT;
    ELSE 
        DBMS_OUTPUT.PUT_LINE('NO ACCOUNTS FOR USER');
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO DEPOSIT TO ACCOUNT');
ROLLBACK;
END;

--NO ERROR MESSAGE IF UNABLE TO WITHDRAW
BEGIN 
    ACCOUNT_WITHDRAWAL(7140,10);
END;


CREATE OR REPLACE TRIGGER UPDATE_TRANSACTION
    AFTER UPDATE OF BALANCE ON ACCOUNTS
    FOR EACH ROW 
    BEGIN
        IF :NEW.BALANCE > :OLD.BALANCE THEN
            DBMS_OUTPUT.PUT_LINE('UPDATE ON TRANSACTION ON DOPOSIT');
            INSERT INTO TRANSACTIONS(TRANSACTIONACCOUNT,TRANSACTIONTYPE,TRANSACTIONTIME, PRIORBALANCE, CURRENTBALANCE)
            VALUES (:NEW.ACCOUNTID, 'D', DEFAULT, :OLD.BALANCE, :NEW.BALANCE);
        ELSE 
            DBMS_OUTPUT.PUT_LINE('UPDATE ON TRANSACTION ON WITHDRAWAL');
            INSERT INTO TRANSACTIONS(TRANSACTIONACCOUNT,TRANSACTIONTYPE,TRANSACTIONTIME, PRIORBALANCE, CURRENTBALANCE)
            VALUES (:NEW.ACCOUNTID, 'W', DEFAULT, :OLD.BALANCE, :NEW.BALANCE);
        END IF;
END;  

BEGIN 
    ACCOUNT_DEPOSIT(7140,10);
END;



CREATE OR REPLACE PROCEDURE VIEW_TRANSACTIONS(AI IN NUMBER, S OUT SYS_REFCURSOR)
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(ACCOUNTID) INTO A_EXISTS FROM ACCOUNTS U WHERE ACCOUNTID = AI;
    IF A_EXISTS > 0 THEN
        OPEN S FOR         
            SELECT T.* FROM TRANSACTIONS T WHERE 
                T.TRANSACTIONACCOUNT IN (SELECT ACCOUNTID FROM ACCOUNTS WHERE ACCOUNTID=AI);
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    ROLLBACK;
END;


DECLARE
S SYS_REFCURSOR;
BEGIN
    VIEW_TRANSACTIONS(5020,S);
END;

