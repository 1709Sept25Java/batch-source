--CREATE SEQUENCES FOR USER, ACCOUNT & TRANSACTION
CREATE SEQUENCE SQ_PK_USER
START WITH 5000
INCREMENT BY 5;

CREATE SEQUENCE SQ_PK_ACCOUNT
START WITH 7000
INCREMENT BY 7;

CREATE SEQUENCE SQ_PK_TRANSACTION
START WITH 9000
INCREMENT BY 9;

CREATE OR REPLACE TRIGGER TR_INSERT_USER
BEFORE INSERT ON USERS
FOR EACH ROW
BEGIN
    SELECT SQ_PK_USER.NEXTVAL INTO :NEW.USERID FROM DUAL;
END;

--TRIGGER FOR PK CREATION OF ACCOUNTS
CREATE OR REPLACE TRIGGER TR_INSERT_ACCOUNT
BEFORE INSERT ON ACCOUNTS
FOR EACH ROW
BEGIN
    SELECT SQ_PK_ACCOUNT.NEXTVAL INTO :NEW.ACCOUNTID FROM DUAL;
END;

--TRIGGER FOR PK CREATION OF ACCOUNTS
CREATE OR REPLACE TRIGGER TR_INSERT_TRANSACTION
BEFORE INSERT ON TRANSACTIONS
FOR EACH ROW
BEGIN
    SELECT SQ_PK_TRANSACTION.NEXTVAL INTO :NEW.TRANSACTIONID FROM DUAL;
END;

--DECLARE USERS, ACCOUNTS & TRANSACTIONS TABLE
CREATE TABLE USERS(
    USERID NUMBER NOT NULL,
    USERNAME VARCHAR2(100) NOT NULL UNIQUE,
    PASSKEY VARCHAR2(100) NOT NULL, --PASSWORD
    USERTYPE VARCHAR2(10) NOT NULL CONSTRAINT UTYPE CHECK (USERTYPE IN ('C','A')), --ONLY TWO TYPES OF USERS: ADMIN OR CUSTOMER
    FIRSTNAME VARCHAR2(40),
    LASTNAME VARCHAR2(20),
    ADDRESS VARCHAR2(70),
    CITY VARCHAR2(40),
    STATE VARCHAR2(40),
    COUNTRY VARCHAR2(40),
    POSTALCODE VARCHAR2(10),
    PHONE VARCHAR2(24),
    EMAIL VARCHAR2(60),
    CONSTRAINT PK_USER PRIMARY KEY (USERID)
);

CREATE TABLE ACCOUNTS (
    ACCOUNTID NUMBER NOT NULL,
    ACCOUNTUSER NUMBER NOT NULL,
    ACCOUNTTYPE VARCHAR2(10) NOT NULL, --CONSTRAINT ATYPE CHECK (ACCOUNTTYPE IN ('C','S')) - DECIDED NOT TO DO THIS
    BALANCE NUMBER NOT NULL,
    ACCOUNTNUMBER VARCHAR2(20) UNIQUE,
    OPENDATE VARCHAR2(50) DEFAULT to_char(CURRENT_TIMESTAMP,'DD-MON-YYYY HH24:MI:SS.FF'), --AVOID PROBLEMS BY CONVERTING TO STRING
    CONSTRAINT PK_ACCOUNT PRIMARY KEY (ACCOUNTID),
    CONSTRAINT FK_ACCOUNT_USER FOREIGN KEY (ACCOUNTUSER) REFERENCES USERS(USERID) ON DELETE CASCADE
);

CREATE TABLE TRANSACTIONS (
    TRANSACTIONID NUMBER NOT NULL,
    TRANSACTIONACCOUNT NUMBER NOT NULL,
    TRANSACTIONTYPE VARCHAR2(10) NOT NULL CONSTRAINT TTYPE CHECK (TRANSACTIONTYPE IN ('W','D')), --ONLY DEPOSIT OR WITHDRAW ALLOWED
    TRANSACTIONTIME VARCHAR2(50) DEFAULT to_char(CURRENT_TIMESTAMP,'DD-MON-YYYY HH24:MI:SS.FF'),  --AVOID PROBLEMS BY CONVERTING TO STRING
    PRIORBALANCE NUMBER NOT NULL,
    CURRENTBALANCE NUMBER NOT NULL,
    CONSTRAINT PK_TRANSACTION PRIMARY KEY (TRANSACTIONID),
    CONSTRAINT FK_TRANSACTION_ACCOUNT FOREIGN KEY (TRANSACTIONACCOUNT) REFERENCES ACCOUNTS(ACCOUNTID) ON DELETE CASCADE
);

--STORED PROCEDURES: MOST PROCEDURES VALIDATE WHETHER ADMIN OR USER EXISTS BEFORE ALLOWING TRANSACTION
--FURTHER SOME PROCEDURES CHECK WHETHER USER OR ACCOUNT EXISTS BEFORE ALLOWING TRANSACTION SO 
--THE PROCEDURE DOESN'T FAIL
--THERE'S A LOT OF ERROR CHECKING 
--SOME PROCEDURES RETURN A 'BOOLEAN' AS A NUMBER THAT SAYS WHETHER TRANSACTION WAS SUCCESSFUL OR NOT
--DUE TO TIME CONSTRAINTS NOT ALL PROCEDURES RETURN A 'BOOLEAN' SUCCESS NUMBER 
--IF CHANGED THEN MORE EXCEPTIONS WOULD BE THROWN IN BANK JAVA PROGRAM

--LOGIN 
--UE > 0 LOGIN SUCESS
--UE = 0 LOGIN FAIL
CREATE OR REPLACE PROCEDURE LOGIN(UN IN VARCHAR2, PW IN VARCHAR2, UE OUT NUMBER, S OUT SYS_REFCURSOR)
IS 
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(USERID) INTO UE FROM USERS WHERE USERNAME=UN AND PASSKEY=PW;
    IF UE > 0 THEN
        OPEN S FOR
            SELECT USERID, USERTYPE FROM USERS WHERE USERNAME=UN AND PASSKEY=PW;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;

--REGISTER
--UE = 0 REGISTER SUCCESS
--UE > 0 REGISTER FAIL
CREATE OR REPLACE PROCEDURE REGISTER_USER(UN IN VARCHAR2, PW IN VARCHAR2, UE OUT NUMBER)
IS 
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 
    SELECT COUNT (USERNAME) INTO UE FROM USERS WHERE USERNAME = UN;
    IF UE = 0 THEN
        INSERT INTO USERS (USERNAME, PASSKEY, USERTYPE)
        VALUES (UN, PW, 'C');
    ELSE 
        UE := 1; 
    END IF;    
END;

--VIEW USERS (ADMIN)
CREATE OR REPLACE PROCEDURE VIEW_USERS(AI IN NUMBER, S OUT SYS_REFCURSOR) 
IS 
AE NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(U.USERID) INTO AE FROM USERS U
    WHERE U.USERID=AI AND U.USERTYPE='A'; 
    IF AE > 0 THEN
        OPEN S FOR
            SELECT USERID, USERNAME, USERTYPE FROM USERS;
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    ROLLBACK;
END;

--CREATE USER
--AC == 0 SUCESS
--AC > 0 FAIL
CREATE OR REPLACE PROCEDURE CREATE_USER(AI IN NUMBER, UN IN VARCHAR2, PW IN VARCHAR2, ACT IN VARCHAR2, AC OUT NUMBER)
IS 
AE NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(USERID) INTO AE FROM USERS WHERE USERID = AI AND USERTYPE = 'A';
    IF AE > 0 THEN
        SELECT COUNT(USERID) INTO AC FROM USERS WHERE USERNAME = UN;
        IF AC = 0 THEN
            INSERT INTO USERS(USERNAME,PASSKEY,USERTYPE)
            VALUES(UN,PW,ACT);
        END IF;
    ELSE 
        AC:=1;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN  
    ROLLBACK;
END;

--UPDATE USER 
--AC > 0 SUCESS
--AC == 0 FAIL
CREATE OR REPLACE PROCEDURE UPDATE_USER(AI IN NUMBER, UI IN NUMBER, UN IN VARCHAR2, PW IN VARCHAR2, UT IN VARCHAR2, AC OUT NUMBER)
IS 
AE NUMBER;
BEGIN 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(USERID) INTO AE FROM USERS 
    WHERE USERID = AI AND USERTYPE = 'A';
    IF AE > 0 THEN
        SELECT COUNT(USERID) INTO AC FROM USERS WHERE USERID = UI;
        IF AC > 0 THEN
            UPDATE USERS
            SET USERNAME = UN, PASSKEY = PW, USERTYPE = UT
            WHERE USERID = UI;
        END IF;
    ELSE
        AC:=0;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
END;

--DELETE USER (ADMIN)
CREATE OR REPLACE PROCEDURE DELETE_USER(AI IN NUMBER, UI IN NUMBER, AC OUT NUMBER) 
IS 
AE NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(USERID) INTO AE FROM USERS
    WHERE USERID = AI AND USERTYPE = 'A';
    IF AE > 0 THEN
        SELECT COUNT(USERID) INTO AC FROM USERS WHERE USERID = UI;
        IF AC > 0 THEN
            DELETE FROM USERS
            WHERE USERID = UI;
        END IF;
      ELSE
        AC:=1;
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
END;

--CREATE ACCOUNT (USER)
CREATE OR REPLACE PROCEDURE CREATE_ACCOUNT(UI IN VARCHAR2, ACT IN VARCHAR, B IN NUMBER) 
IS 
U_EXISTS NUMBER;
BEGIN 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(U.USERID) INTO U_EXISTS FROM USERS U
WHERE U.USERID = UI;
    IF U_EXISTS > 0 THEN
        INSERT INTO ACCOUNTS(ACCOUNTUSER, ACCOUNTTYPE, BALANCE, OPENDATE)
        VALUES(UI, ACT, B, DEFAULT);
        DBMS_OUTPUT.PUT_LINE('CREATED ACCOUNT');

    ELSE
        DBMS_OUTPUT.PUT_LINE('ERROR THAT USER DOES NOT EXIST');
    END IF;
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('EXCEPTION ERROR');
    ROLLBACK;
END;

--VIEW ACCOUNTS (USER)
CREATE OR REPLACE PROCEDURE VIEW_ACCOUNTS(UI IN NUMBER, S OUT SYS_REFCURSOR) 
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTUSER) INTO A_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTUSER=UI; 
    IF A_EXISTS > 0 THEN
        OPEN S FOR
        SELECT ACCOUNTID, ACCOUNTUSER, ACCOUNTTYPE, BALANCE, OPENDATE FROM ACCOUNTS A
        WHERE A.ACCOUNTUSER = UI; 
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    ROLLBACK;
END;

--DELETE ACCOUNT (USER)
CREATE OR REPLACE PROCEDURE DELETE_ACCOUNT(AI IN NUMBER, S OUT SYS_REFCURSOR)
IS 
UA_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTID) INTO UA_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTID=AI; 
    IF UA_EXISTS > 0 THEN
        DELETE ACCOUNTS A
        WHERE A.ACCOUNTID = AI AND A.BALANCE = 0; 
        DBMS_OUTPUT.PUT_LINE('DELETE ACCOUNT: '||AI);
    ELSE 
        DBMS_OUTPUT.PUT_LINE('NO ACCOUNTS FOR USER');
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO RETRIEVE ACCOUNTS');

ROLLBACK;
END;

--DEPOSIT ACCOUNT (USER)
--SC = 0 SUCCESS
--SC > 0 FAIL
CREATE OR REPLACE PROCEDURE ACCOUNT_DEPOSIT(AI IN NUMBER, AMT IN NUMBER, SC OUT NUMBER)
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTID) INTO A_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTID=AI; 
    IF A_EXISTS > 0 THEN 
        UPDATE ACCOUNTS A
            SET BALANCE = (AMT + A.BALANCE)
        WHERE A.ACCOUNTID = AI;
        SC:=0;
    ELSE 
        SC:=1;
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('FAILED TO DEPOSIT TO ACCOUNT');
ROLLBACK;
END;

--ACCOUNT WITHDRAW(USER)
--SC = 0 SUCCESS
--SC > 0 FAIL
CREATE OR REPLACE PROCEDURE ACCOUNT_WITHDRAWAL(AI IN NUMBER, AMT IN NUMBER, SC OUT NUMBER)
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(A.ACCOUNTID) INTO A_EXISTS FROM ACCOUNTS A
    WHERE A.ACCOUNTID=AI; 
    IF A_EXISTS > 0 THEN 
        UPDATE ACCOUNTS A
            SET BALANCE = (A.BALANCE - AMT)
            WHERE A.ACCOUNTID = AI AND A.BALANCE >= AMT;
            SC:=0;
    ELSE 
        SC:=1;
    END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    ROLLBACK;
END;

--TRIGGER TO RECORD TRANSACTION HAPPENS UPON AN UPDATE TO BALANCE COLUMN OF ACCOUNT
CREATE OR REPLACE TRIGGER UPDATE_TRANSACTION
    AFTER UPDATE OF BALANCE ON ACCOUNTS
    FOR EACH ROW 
    BEGIN
        IF :NEW.BALANCE > :OLD.BALANCE THEN
            DBMS_OUTPUT.PUT_LINE('UPDATE ON TRANSACTION ON DOPOSIT');
            INSERT INTO TRANSACTIONS(TRANSACTIONACCOUNT,TRANSACTIONTYPE,TRANSACTIONTIME, PRIORBALANCE, CURRENTBALANCE)
            VALUES (:NEW.ACCOUNTID, 'D', DEFAULT, :OLD.BALANCE, :NEW.BALANCE);
        ELSE 
            DBMS_OUTPUT.PUT_LINE('UPDATE ON TRANSACTION ON WITHDRAWAL');
            INSERT INTO TRANSACTIONS(TRANSACTIONACCOUNT,TRANSACTIONTYPE,TRANSACTIONTIME, PRIORBALANCE, CURRENTBALANCE)
            VALUES (:NEW.ACCOUNTID, 'W', DEFAULT, :OLD.BALANCE, :NEW.BALANCE);
        END IF;
END;  

CREATE OR REPLACE PROCEDURE VIEW_TRANSACTIONS(AI IN NUMBER, S OUT SYS_REFCURSOR)
IS 
A_EXISTS NUMBER;
BEGIN 
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    SELECT COUNT(ACCOUNTID) INTO A_EXISTS FROM ACCOUNTS U WHERE ACCOUNTID = AI;
    IF A_EXISTS > 0 THEN
        OPEN S FOR         
            SELECT T.* FROM TRANSACTIONS T WHERE 
                T.TRANSACTIONACCOUNT IN (SELECT ACCOUNTID FROM ACCOUNTS WHERE ACCOUNTID=AI);
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
    ROLLBACK;
END;
