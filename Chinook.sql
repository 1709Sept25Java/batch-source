/*Chinook SQL Lab
2.0 SQL QUERIES

2.1 SELECT*/

--Select all records from the Employee table.
SELECT * FROM EMPLOYEE;

--Select all records from the Employee table where last name is King.
SELECT * 
FROM EMPLOYEE 
WHERE LASTNAME = 'King';

--Select all records from the Employee table where first name is Andrew and REPORTSTO is NULL.
SELECT *
FROM EMPLOYEE
WHERE FIRSTNAME = 'Andrew' AND REPORTSTO IS NULL;

/*2.2 ORDER BY*/

--Select all albums in Album table and sort result set in descending order by title.
SELECT *
FROM ALBUM 
ORDER BY TITLE DESC;

--Select first name from Customer and sort result set in ascending order by city
SELECT FIRSTNAME
FROM CUSTOMER
ORDER BY CITY ASC;

/*2.3 INSERT INTO*/

--Insert two new records into Genre table
INSERT INTO GENRE VALUES (26, 'J-POP');
INSERT INTO GENRE VALUES (27, 'K-POP');

--Insert two new records into Employee table
INSERT INTO EMPLOYEE(EMPLOYEEID, LASTNAME, FIRSTNAME) VALUES (9, 'Pop', 'Bob');
INSERT INTO EMPLOYEE(EMPLOYEEID, LASTNAME, FIRSTNAME) VALUES (10, 'Smith', 'John');

--Insert two new records into Customer table
INSERT INTO CUSTOMER(CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL) VALUES (60, 'Bob', 'Pop', 'bobpop@gmail.com');
INSERT INTO CUSTOMER(CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL) VALUES (61, 'Mary', 'Poppins', 'marypoppins@gmail.com');

/*2.4 UPDATE*/

--Update Aaron Mitchell in Customer table to Robert Walter
UPDATE CUSTOMER 
SET FIRSTNAME = 'Robert', LASTNAME = 'Walter'
WHERE FIRSTNAME = 'Aaron' AND LASTNAME = 'Mitchell';

--Update name of artist in the Artist table “Creedence Clearwater Revival” to “CCR”
UPDATE ARTIST
SET NAME = 'CCR'
WHERE NAME = 'Creedence Clearwater Revival';

/*2.5 LIKE*/

--Select all invoices with a billing address like “T%”
SELECT * 
FROM INVOICE 
WHERE BILLINGADDRESS LIKE 'T%';

/*2.6 BETWEEN*/

--Select all invoices that have a total between 15 and 50
SELECT *
FROM INVOICE
WHERE TOTAL BETWEEN 15 AND 20;

--Select all employees hired between 1st of June 2003 and 1st of March 2004
SELECT *
FROM EMPLOYEE
WHERE HIREDATE BETWEEN '1-JUN-2003' AND '1-MAR-2004';

/*2.7 DELETE
 
Delete a record in Customer table where the name is Robert Walter 
(There may be constraints that rely on this, find out how to resolve them). 
*/

ALTER TABLE INVOICE 
DROP CONSTRAINT FK_INVOICECUSTOMERID;

DELETE FROM CUSTOMER WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter';

/*SQL FUNCTIONS

3.1 SYSTEM DEFINED FUNCTIONS*/

--Create a function that returns the current time.
SELECT TO_CHAR(CURRENT_TIMESTAMP, 'HH:MI;SS') FROM DUAL;

--Create a function that returns the length of name in MEDIATYPE table
SELECT NAME, LENGTH(NAME) AS LENGTH_OF_NAME
FROM MEDIATYPE;

/*3.2 SYSTEM DEFINED AGGREGATE FUNCTIONS*/

--Create a function that returns the average total of all invoices
SELECT AVG(TOTAL) FROM INVOICE;

--Create a function that returns the most expensive track
SELECT NAME, UNITPRICE
FROM TRACK
WHERE UNITPRICE = (SELECT MAX(UNITPRICE) FROM TRACK);

/*3.3 USER DEFINE SCALAR FUNCTIONS*/

--Create a function that returns the average price of invoiceline items in the invoiceline table
CREATE OR REPLACE FUNCTION AVG_PRICE
RETURN NUMBER
IS
Z NUMBER;
BEGIN
    SELECT SUM(UNITPRICE)/COUNT(QUANTITY) INTO Z
    FROM INVOICELINE;
    RETURN Z;
END;

SELECT AVG_PRICE() FROM DUAL;

/*3.4 USER DEFINE TABLE VALUED FUNCTION*/

--Create a function that returns all employees who are born after 1968.
CREATE OR REPLACE FUNCTION BD_AFTER1968
RETURN SYS_REFCURSOR
AS
C1 SYS_REFCURSOR;
BEGIN
OPEN C1 FOR 
SELECT EMPLOYEEID, LASTNAME, FIRSTNAME, BIRTHDATE 
FROM EMPLOYEE WHERE BIRTHDATE > '31-DEC-68';
RETURN C1;
END BD_AFTER1968;

SELECT BD_AFTER1968() FROM DUAL;
/*4.0 STORED PROCEDURES

4.1 BASIC STORED PROCEDURE
*/

--Create a stored procedure that selects the first and last names of all the employees.
CREATE OR REPLACE PROCEDURE FIRST_AND_LAST (S OUT SYS_REFCURSOR)
IS BEGIN 
OPEN S FOR 
SELECT FIRSTNAME, LASTNAME FROM EMPLOYEE;
END;

DECLARE
S SYS_REFCURSOR;
SOME_FIRSTNAME EMPLOYEE.FIRSTNAME%TYPE;
SOME_LASTNAME EMPLOYEE.LASTNAME%TYPE;
BEGIN
    FIRST_AND_LAST(S);
    LOOP
        FETCH S INTO SOME_FIRSTNAME, SOME_LASTNAME;
        EXIT WHEN S%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('FIRSTNAME: ' || SOME_FIRSTNAME 
        || ' LASTNAME: ' || SOME_LASTNAME);
    END LOOP;
    CLOSE S;
END;

/*4.2 STORED PROCEDURE INPUT PARAMETERS*/

--Create a stored procedure that updates the personal information of an employee.
CREATE OR REPLACE PROCEDURE UPDATE_INFO(EM_ID IN NUMBER, INFO_NAME IN VARCHAR2, 
NEW_INFO IN VARCHAR2)
IS 
ID_EXISTS INTEGER;
BEGIN
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(EM.EMPLOYEEID) INTO ID_EXISTS FROM EMPLOYEE EM
WHERE EM.EMPLOYEEID = EM_ID;
DBMS_OUTPUT.PUT_LINE(ID_EXISTS);
IF ID_EXISTS > 0 THEN
    IF INFO_NAME = 'LASTNAME' THEN
        UPDATE EMPLOYEE
        SET LASTNAME = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'FIRSTNAME' THEN
        UPDATE EMPLOYEE
        SET FIRSTNAME = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'TITLE' THEN
        UPDATE EMPLOYEE
        SET TITLE = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'ADDRESS' THEN
        UPDATE EMPLOYEE
        SET ADDRESS = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'CITY' THEN
        UPDATE EMPLOYEE
        SET CITY = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'STATE' THEN
        UPDATE EMPLOYEE
        SET STATE = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'COUNTRY' THEN
        UPDATE EMPLOYEE
        SET COUNTRY = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'POSTALCODE' THEN
        UPDATE EMPLOYEE
        SET POSTALCODE = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'ADDRESS' THEN
        UPDATE EMPLOYEE
        SET ADDRESS = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'PHONE' THEN
        UPDATE EMPLOYEE
        SET PHONE = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'FAX' THEN
        UPDATE EMPLOYEE
        SET FAX = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    ELSIF INFO_NAME = 'EMAIL' THEN
        UPDATE EMPLOYEE
        SET EMAIL = NEW_INFO
        WHERE EMPLOYEEID = EM_ID;
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID || ' HAD HIS/HER ' 
        || INFO_NAME || ' UPDATED TO ' || NEW_INFO);
    END IF;
ELSE 
  DBMS_OUTPUT.PUT_LINE('EMPLOYEEID DOES NOT EXIST');
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('FAILED TO UPDATE');
ROLLBACK;
END;
    
BEGIN
UPDATE_INFO(1, 'FIRSTNAME', 'DAVE');
END;
 
 --PROCEDURE TO UPDATE REPORTSTO   
CREATE OR REPLACE PROCEDURE 
UPDATE_REPORTSTO(EM_ID IN NUMBER, REPORTSTO_ID IN NUMBER)
IS 
ID_EXISTS INTEGER;
BEGIN
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(EM.EMPLOYEEID) INTO ID_EXISTS FROM EMPLOYEE EM
WHERE EM.EMPLOYEEID = EM_ID;
DBMS_OUTPUT.PUT_LINE(ID_EXISTS);
IF ID_EXISTS > 0 THEN
  UPDATE EMPLOYEE 
  SET REPORTSTO = REPORTSTO_ID
  WHERE EMPLOYEEID = EM_ID;
  DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID 
  || ' NOW REPORTS TO ' || REPORTSTO_ID);
ELSE 
  DBMS_OUTPUT.PUT_LINE('EMPLOYEEID DOES NOT EXIST');
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('FAILED TO UPDATE');
ROLLBACK;
END;  
 
BEGIN
UPDATE_REPORTSTO(2, 2);
END;

 --PROCEDURE TO UPDATE BIRTHDATE/HIREDATE  
CREATE OR REPLACE PROCEDURE 
UPDATE_DATE(EM_ID IN NUMBER, WHICH_DATE IN VARCHAR2, NEW_DATE IN DATE)
IS 
ID_EXISTS INTEGER;
BEGIN
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(EM.EMPLOYEEID) INTO ID_EXISTS FROM EMPLOYEE EM
WHERE EM.EMPLOYEEID = EM_ID;
DBMS_OUTPUT.PUT_LINE(ID_EXISTS);
IF ID_EXISTS > 0 THEN
    IF WHICH_DATE = 'HIREDATE' THEN
      UPDATE EMPLOYEE 
      SET HIREDATE = NEW_DATE
      WHERE EMPLOYEEID = EM_ID;
      DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID 
      || ' HAS NEW HIREDATE OF ' || NEW_DATE);
    ELSIF WHICH_DATE = 'BIRTHDATE' THEN
      UPDATE EMPLOYEE 
      SET BIRTHDATE = NEW_DATE
      WHERE EMPLOYEEID = EM_ID;
      DBMS_OUTPUT.PUT_LINE('EMPLOYEE ' || EM_ID 
      || ' HAS NEW BIRTHDATE OF ' || NEW_DATE);  
    END IF;
ELSE 
  DBMS_OUTPUT.PUT_LINE('EMPLOYEEID DOES NOT EXIST');
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('FAILED TO UPDATE');
ROLLBACK;
END;  
 
BEGIN
UPDATE_DATE(1, 'BIRTHDATE', '22-APR-64');
END;

--Create a stored procedure that returns the managers of an employee.
CREATE OR REPLACE PROCEDURE FIND_MANAGER(EM_ID IN NUMBER)
IS
MANAGER_FN VARCHAR2(100);
MANAGER_LN VARCHAR2(100);
EM_FN VARCHAR2(100);
EM_LN VARCHAR2(100);
BEGIN
SELECT FIRSTNAME, LASTNAME 
INTO MANAGER_FN, MANAGER_LN
FROM EMPLOYEE
WHERE EMPLOYEEID = 
    (SELECT REPORTSTO
    FROM EMPLOYEE 
    WHERE EMPLOYEEID = EM_ID);
SELECT FIRSTNAME, LASTNAME
INTO EM_FN, EM_LN
FROM EMPLOYEE
WHERE EMPLOYEEID = EM_ID;
DBMS_OUTPUT.PUT_LINE(MANAGER_FN || ' ' || MANAGER_LN 
|| ' IS THE MANAGER OF ' || EM_FN || ' ' || EM_LN);
END;

BEGIN
FIND_MANAGER(5);
END;

/*4.3 STORED PROCEDURE OUTPUT PARAMETERS*/

--Create a stored procedure that returns the name and company of a customer.
CREATE OR REPLACE PROCEDURE GET_NAME_COMPANY(CUSTOMER_ID IN NUMBER)
IS 
F_NAME VARCHAR2(100);
L_NAME VARCHAR2(100);
COMP_NAME VARCHAR2(100);
BEGIN
SELECT FIRSTNAME, LASTNAME, COMPANY
INTO F_NAME, L_NAME, COMP_NAME
FROM CUSTOMER
WHERE CUSTOMERID = CUSTOMER_ID;
DBMS_OUTPUT.PUT_LINE(COMP_NAME || ' IS THE COMPANY FOR ' 
|| F_NAME || ' ' || L_NAME);
END;

BEGIN
GET_NAME_COMPANY(19);
END;

/*5.0 TRANSACTIONS*/

--Create a transaction that given a invoiceId will delete that invoice 
--(There may be constraints that rely on this, find out how to resolve them).
ALTER TABLE INVOICELINE
DROP CONSTRAINT FK_INVOICELINEINVOICEID;

CREATE OR REPLACE PROCEDURE DELETE_INVOICE(INVOICE_ID IN NUMBER)
IS
ID_EXIST INTEGER;
BEGIN
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(INVOICEID) INTO ID_EXIST FROM INVOICE 
WHERE INVOICEID = INVOICE_ID;
IF ID_EXIST > 0 THEN
   DELETE FROM INVOICE WHERE INVOICEID = INVOICE_ID;
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
ROLLBACK;
END;

BEGIN
DELETE_INVOICE(112);
END;

--Create a transaction nested within a stored procedure that inserts a new record in the Customer table
CREATE OR REPLACE PROCEDURE INSERT_CUSTOMER
(CUST_ID IN NUMBER, F_NAME IN VARCHAR2, L_NAME IN VARCHAR2, NEW_EMAIL IN VARCHAR2)
IS
ID_EXIST INTEGER;
BEGIN
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(CUSTOMERID) INTO ID_EXIST
FROM CUSTOMER
WHERE CUSTOMERID = CUST_ID;
DBMS_OUTPUT.PUT_LINE(ID_EXIST);
IF ID_EXIST = 0 THEN
    INSERT INTO CUSTOMER(CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL)
    VALUES (CUST_ID, F_NAME, L_NAME, NEW_EMAIL);
    DBMS_OUTPUT.PUT_LINE('INSERT COMPLETED');
ELSE
    DBMS_OUTPUT.PUT_LINE('CUSTOMER WITH THAT SPECIFIC ID ALREADY EXISTS');
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN 
DBMS_OUTPUT.PUT_LINE('FAILED TO INSERT NEW CUSTOMER');
ROLLBACK;
END;

BEGIN
INSERT_CUSTOMER(62, 'JIM', 'SMITH', 'JIMSMITH@GMAIL.COM');
END;

/*6.0 TRIGGERS

6.1 AFTER/FOR
*/

 -- Create an after insert trigger on the employee table fired after a new record is inserted into the table.
CREATE OR REPLACE TRIGGER AFTER_INSERT_EMP
AFTER INSERT ON EMPLOYEE
FOR EACH ROW
BEGIN
    INSERT INTO EMPLOYEE(EMPLOYEEID, FIRSTNAME, LASTNAME)
    VALUES(:NEW.EMPLOYEEID, :NEW.FIRSTNAME, :NEW.LASTNAME);
END;

--Create an after update trigger on the album table that fires after a row is inserted in the table
CREATE OR REPLACE TRIGGER AFTER_UPDATE_ALBUM
AFTER UPDATE ON ALBUM
FOR EACH ROW 
BEGIN
    INSERT INTO ALBUM(ALBUMID, TITLE, ARTISTID)
    VALUES(:NEW.ALBUMID, :NEW.TITLE, :NEW.ARTISTID);
END;

--Create an after delete trigger on the customer table that fires after a row is deleted from the table.
CREATE OR REPLACE TRIGGER AFTER_DELETE_CUSTOMER
AFTER DELETE ON CUSTOMER
FOR EACH ROW
BEGIN
    INSERT INTO CUSTOMER(CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL)
    VALUES(:NEW.CUSTOMERID, :NEW.FIRSTNAME, :NEW.LASTNAME, :NEW.EMAIL);
END;

/*7.0 JOINS

7.1 INNER*/

--Create an inner join that joins customers and orders and specifies the name of the customer and the invoiceId.
SELECT I.INVOICEID, C.FIRSTNAME, C.LASTNAME
FROM INVOICE I
INNER JOIN CUSTOMER C ON I.CUSTOMERID = C.CUSTOMERID;

/*7.2 OUTER*/

--Create an outer join that joins the customer and invoice table, specifying the CustomerId, firstname, lastname, invoiceId, and total.
SELECT C.CUSTOMERID, C.FIRSTNAME, C.LASTNAME, I.INVOICEID, I.TOTAL
FROM INVOICE I
FULL OUTER JOIN CUSTOMER C ON I.CUSTOMERID = C.CUSTOMERID;

/*7.3 RIGHT*/

--Create a right join that joins album and artist specifying artist name and title.
SELECT AR.NAME, AL.TITLE
FROM ARTIST AR
RIGHT JOIN ALBUM AL ON AR.ARTISTID = AL.ARTISTID;

/*7.4 CROSS*/

--Create a cross join that joins album and artist and sorts by artist name in ascending order.
SELECT *
FROM ALBUM AL
CROSS JOIN ARTIST AR
ORDER BY AR.NAME ASC;

/*7.5 SELF*/

--Perform a self-join on the employee table, joining on the reportsto column.
SELECT A.FIRSTNAME AS EMP_FIRSTNAME1, A.LASTNAME AS EMP_LASTNAME1,
A.REPORTSTO, B.FIRSTNAME AS EMP_FIRSTNAME2, B.LASTNAME AS EMP_LASTNAME2
FROM EMPLOYEE A, EMPLOYEE B
WHERE A.EMPLOYEEID <> B.EMPLOYEEID
AND A.REPORTSTO = B.REPORTSTO
ORDER BY A.REPORTSTO;

/*9.0 ADMINISTRATION*/

--Create a .sql file for the Chinook database.
--Backup .sql file will be uploaded along with solutions to GitHub



